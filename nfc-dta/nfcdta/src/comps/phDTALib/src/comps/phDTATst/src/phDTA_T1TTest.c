/*
 *                    Copyright (c), NXP Semiconductors
 *
 *                       (C)NXP Semiconductors B.V.2014
 *         All rights are reserved. Reproduction in whole or in part is
 *        prohibited without the written consent of the copyright owner.
 *    NXP reserves the right to make changes without notice at any time.
 *   NXP makes no warranty, expressed, implied or statutory, including but
 *   not limited to any implied warranty of merchantability or fitness for any
 *  particular purpose, or that the use will not infringe any third party patent,
 *   copyright or trademark. NXP must not be liable for any loss or damage
 *                            arising from its use.
 *
 */

/*!
 * \file phDTA_T1TTest.c
 *
 * Project: NFC DTA
 *
 */
/* Preprocessor includes for different platform */
#ifdef WIN32
#include <windows.h>
#include "phNfcTypes.h"
#else
#include <utils/Log.h>
#include "data_types.h"
#endif

#include "phMwIf.h"
#include "phDTALib.h"
#include "phDTAOSAL.h"
#include "phOsal_LinkList.h"
#include "phOsal_Queue.h"
#include "phDTATst.h"

extern phDtaLib_sHandle_t g_DtaLibHdl;

/**< Constant T1T Data Arrays for predefined memory layouts*/
static const uint8_t gs_T1TStaticLayoutZeroLenTagData[] = { 0x01, 0x61, 0x62, 0x63,
        0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
        0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
        0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
        0x2E, 0x63, 0x6F, 0x6D };

static const uint8_t gs_T1TStaticLayoutNonZeroLenTagData[] = { 0x01, 0x61, 0x62, 0x63,
        0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
        0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
        0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
        0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
        0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61,
        0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
        0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
        0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x2E, 0x63,
        0x6F, 0x6D };

static const uint8_t gs_T1TDynamicLayoutZeroLenTagData[] = { 0x01, 0x61, 0x62, 0x63,
        0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
        0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
        0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
        0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
        0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61,
        0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
        0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
        0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65,
        0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
        0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
        0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
        0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73,
        0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63,
        0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D,
        0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
        0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
        0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71,
        0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61,
        0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B,
        0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75,
        0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65,
        0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
        0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
        0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
        0x6A, 0x6B, 0x2E, 0x63, 0x6F, 0x6D };

static const uint8_t gs_T1TDynamicLayoutNonZeroLenTagData[] = { 0x01, 0x61, 0x62,
        0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C,
        0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
        0x6B, 0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74,
        0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64,
        0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
        0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
        0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72,
        0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62,
        0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C,
        0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
        0x6B, 0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72, 0x73, 0x74,
        0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64,
        0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
        0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
        0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72,
        0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62,
        0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C,
        0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0X6F, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
        0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74,
        0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64,
        0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
        0X6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
        0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
        0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0X6F, 0x70, 0x71, 0x72,
        0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x61, 0x62,
        0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C,
        0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
        0x77, 0x78, 0x79, 0x7A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
        0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0X6F, 0x70,
        0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
        0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x2E, 0x63, 0x6F,
        0x6D };

/**
 * Handle T1T Tag operations(Read/Write) based on the pattern number configured
 */
DTASTATUS phDtaLibi_T1TOperations(phDtaLib_sTestProfile_t TestProfile)
{
    phMwIf_uTagOpsParams_t sTagOpsParams;
    phMwIf_sBuffParams_t*  psBuffParams;
    phMwIf_sNdefDetectParams_t* psNdefDetectParams;
    uint8_t* pBuffer;
    uint32_t dwSizeOfBuffer;
    DTASTATUS dwDtaStatus;
    LOG_FUNCTION_ENTRY;

    phOsal_LogDebug((const uint8_t*)"DTALib> T1T:Perform NDEF Check");
    dwDtaStatus = phDtaLibi_CheckNDEF((void*)(&sTagOpsParams.sNdefDetectParams));
    if (dwDtaStatus != DTASTATUS_SUCCESS)
    {
        phOsal_LogError((const uint8_t*)"DTALib>Device is not NDEF Compliant");
        return dwDtaStatus;
    }

    /**< Select operation based on pattern number */
    phOsal_LogDebugU32h((const uint8_t*)"DTALib>T1T:pattern number ", TestProfile.Pattern_Number);
    switch (TestProfile.Pattern_Number)
    {
        case 0x0001:
        phOsal_LogDebug((const uint8_t*)"DTALib> T1T:Perform NDEF Read \n");
        dwDtaStatus = phDtaLibi_ReadNDEF(&sTagOpsParams);
        if (dwDtaStatus != DTASTATUS_SUCCESS)
        {
            phOsal_LogError((const uint8_t*)"DTALib> Device is not NDEF Compliant");
            return dwDtaStatus;
        }
        break;
        case 0x0002:
        {
            psNdefDetectParams = (void *)(&sTagOpsParams.sNdefDetectParams);

            /* Perform NDEF Message generation based on the sizes*/
            if (psNdefDetectParams->dwMaxSize > 0x5A) /*Dynamic Layout*/
            {
                if (psNdefDetectParams->dwCurSize == 0)/*Zero Size*/
                {
                    phOsal_LogDebug((const uint8_t*)"DTALib>T1T:Dynamic Zero Len \n");
                    pBuffer = (uint8_t *)gs_T1TDynamicLayoutZeroLenTagData;
                    dwSizeOfBuffer = sizeof(gs_T1TDynamicLayoutZeroLenTagData);

                }
                else /*Non Zero Size*/
                {
                    phOsal_LogDebug((const uint8_t*)"DTALib>T1T:Dynamic Non Zero Len \n");
                    pBuffer = (uint8_t *) gs_T1TDynamicLayoutNonZeroLenTagData;
                    dwSizeOfBuffer = sizeof(gs_T1TDynamicLayoutNonZeroLenTagData);
                }
            }
            else /*Static Layout*/
            {
                if (psNdefDetectParams->dwCurSize == 0) /*Zero Size*/
                {
                    phOsal_LogDebug((const uint8_t*)"DTALib>T1T:Static Zero Len \n");
                    pBuffer = (uint8_t *) gs_T1TStaticLayoutZeroLenTagData;
                    dwSizeOfBuffer = sizeof(gs_T1TStaticLayoutZeroLenTagData);
                }
                else /*Non Zero Size*/
                {
                    phOsal_LogDebug((const uint8_t*)"DTALib>T1T:Static Non Zero Len \n");
                    pBuffer = (uint8_t *) gs_T1TStaticLayoutNonZeroLenTagData;
                    dwSizeOfBuffer = sizeof(gs_T1TStaticLayoutNonZeroLenTagData);
                }
            }
            /* Write the NDEF Message */
            phOsal_LogDebug((const uint8_t*)"DTALib> T1T:Perform NDEF Write \n");
            psBuffParams = (void *)(&sTagOpsParams);
            psBuffParams->pbBuff = pBuffer;
            psBuffParams->dwBuffLength = dwSizeOfBuffer;
            dwDtaStatus = phDtaLibi_WriteNDEF(&sTagOpsParams);
            if (dwDtaStatus != DTASTATUS_SUCCESS)
            {
                phOsal_LogError((const uint8_t*)"DTALib> T1T:Error Could not form the NDEF message !!\n");
                break;
            }
        }
        break;
        case 0x0003:
        phOsal_LogDebug((const uint8_t*)"DTALib>T1T:Perform Read-Only conversion \n");
        dwDtaStatus = phDtaLibi_SetTagReadOnly(&sTagOpsParams);
        if (dwDtaStatus != DTASTATUS_SUCCESS)
        {
            phOsal_LogError((const uint8_t*)"DTALib> T1T:Error Could not set tag readonly !!\n");
            break;
        }
        break;
        default:
        phOsal_LogError((const uint8_t*)"DTALib>T1T: Error  Pattern Number not valid for T1T !! \n");
        break;
    }
    LOG_FUNCTION_EXIT;
    return dwDtaStatus;
}
